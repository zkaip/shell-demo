Shell Study
===
## day01~day05
- `>` 改变标准输出
- `<` 改变标准输入
- `|` 前一个标准输出变成后一个的标准输入

`#!`
- 对 `#!` 这一行的长度尽量不要超过 64 个字符
- 脚本的可移植性取决于是否有完整的路径名称
- 不要在选项之后放置任何空白，因为空白也会跟着选项一起传递给被引用的程序
- 需要知道解释器的完成路径的名称。 这样可以规避可移植性的问题， 厂商不同，同样的东西可能放在不同的地方
- 一些较久的系统，内核不具备 `#!` 的能力，有些 shell 会自行处理，这些 shell 对于 `#!` 与紧随其后的解释器名称之间是否可以有空白，可能有不同的解释

**常用命令**
`echo [string...]` **输出到终端**
- `\n:` 换行
- `\r:` 回车
- `\t:` 水平制表符
- `\v:` 垂直制表符
- `\\:` 反斜杠字符

`printf format-string [arguments....]` **以指定格式输出到终端**

`tr [options] cource-char-file replace-char-list` **自标准输入读取字符，再将结果写到标准输出**
- `-c`: 取 source-char-list 的反义，tr 要转换的字符编程位列在 source-char-list 中的字符，通常与选项 -d.-s 配合使用。
- `-d`: 删除标准输入里的字符，不是转换他们
- `-s`: 产出重复的字符，如果标准输入里出现了重复多次的 source-char-list 里所列的字符，将其浓缩成一个。

## day06~day10
**$1** 当数字大于9时,用`{}`,例如 `$10` 其中数字表明命令参数位置

`$PATH` 环境变量路径 终端会查找该目录

**正则表达式 分组**
`()` `\1\2\3...` *grep '^(barlow).*\1' /etc/passwd 搜索 /etc/passwd 中以 barlow 开头，而后面还存在 barlow 的行*

**正则运算符**
- `\w` 匹配任何单词组成字符
- `\W` 匹配任何非单词组成字符
- `\<` `\>` 匹配单词的起始和结尾
- `\b` 匹配单的起始或结尾处所找到的空字符串 `/ `这是 `\<` 与 `>\` 运算符的结合. 注意: 由于 `awk` 使用 `\b` 表示后退运算符, 因此 GNU awk(gawk) 使用 `\y` 表示此功能。
- `\B` 匹配两个单词组成字符之间的空字符串
- `\’ \ `` 分别匹配 emacs 缓冲区的开始与结尾.GNU 程序 (wmacs) 通常将他们是位 ^ 和 $ 同义。

**常用命令**
`grep` 模式匹配
- grep: 最常用，可以检索目标 (一个活多个单词或正则表达式)。
- egrep: 支持丰富的正则表达式，而且支持多目标检索，等同于 grep -e。

- BRE: 基本正则表达式（Basic Regular Expression）
- ERE: 扩展的正则表达式（Extended Regular Expression）

`sed` 流编辑器, 以行对输入进行处理, 处理的是文件的拷贝 
- `-e`: 执行命令行中的指令，例如：sed -e 'command' file(s)
- `-f`: 执行一个 sed 脚本文件中的指令，例如： sed -f scriptfile file(s)
- `-i`: 与 -e 的区别在于：当使用 -e 时，sed 执行指令并不会修改原输入文件的内容，只会显示在 bash 中，而使用 -i 选项时，sed 执行的指令会直接修改原输入文件。
- `-n`: 读取下一行到 pattern space。